<       docholesky=.true.
<       call g2g_timer_start('cholesky')
176a205,215
> 
> 
> !##########################################################!
> ! FFR - NEW FORCE
> !
> !    Diferent ways of diagonalizing S.
> !
> !##########################################################!
> 
>       docholesky=.true.
>       dolowdin=.FALSE.
177a217,223
>         call g2g_timer_start('cholesky')
> ! OLD METHOD
> !        ALLOCATE(Y(M,M),Ytrans(M,M),Xfran(M,M),Xtrans(M,M))
> !        ALLOCATE(Lmat(M,M),Linv(M,M),Umat(M,M),Uinv(M,M))
> !        CALL spunpack('L',M,RMM(M5),SMaux)
> !        CALL cholesky_sdiag(M,RMM(M5),Y,Xtrans,Ytrans,Xfran)
> 
180a227,228
>         ALLOCATE(Xfran(M,M))
>         ALLOCATE(Lmat(M,M),Linv(M,M),Umat(M,M),Uinv(M,M))
211a260,261
>         ALLOCATE(Xfran(M,M))
>         ALLOCATE(Lmat(M,M),Linv(M,M),Umat(M,M),Uinv(M,M))
233,234d282
< 
< 
236,237c284
<       ELSE
< 
---
>         call g2g_timer_stop('cholesky')
239,243c286,308
< c ESSL OPTION ------------------------------------------
<         do i=1,MM
<          rmm5(i)=RMM(M5+i-1)
< c        write(56,*) RMM(M15+1)
<         enddo
---
>        ELSE IF (dolowdin) THEN
>          ALLOCATE(Y(M,M),Ytrans(M,M),Xfran(M,M),Xtrans(M,M))
>          ALLOCATE(Lmat(M,M),Linv(M,M),Umat(M,M),Uinv(M,M))
>          CALL g2g_timer_start('lowdin')
>          CALL lowdin_sdiag
>      >        (M,RMM(M5),Xfran,Xtrans,Y,Ytrans,eigvec,eigval)
>          CALL g2g_timer_stop('lowdin')
> 
> 
>        ELSE
>          ALLOCATE(Y(M,M),Ytrans(M,M),Xfran(M,M),Xtrans(M,M))
>          ALLOCATE(Lmat(M,M),Linv(M,M),Umat(M,M),Uinv(M,M))
> !      ...
> !
> !----------------------------------------------------------!
> !
> c----------------------------------------------------------c
> c ESSL OPTION
> c
>          do i=1,MM
>            rmm5(i)=RMM(M5+i-1)
> c           write(56,*) RMM(M15+1)
>          enddo
245c310
<         call DSPEV(1,RMM(M5),RMM(M13),X,M,M,RMM(M15),M2)
---
>          call DSPEV(1,RMM(M5),RMM(M13),X,M,M,RMM(M15),M2)
246a312,313
> c----------------------------------------------------------c
> c LAPACK OPTION
248d314
< c LAPACK OPTION -----------------------------------------
251d316
< 
255a321,322
> 
> 
257d323
<         allocate (Y(M,M),Ytrans(M,M),Xtrans(M,M))
285a352,354
> c-----------------------------------------------------------
> c
>        ENDIF
287d355
<       ENDIF
289c357,373
<       call g2g_timer_stop('cholesky')
---
> !
>        IF ((docholesky).OR.(dolowdin)) THEN
>          DO iii=1,M
>          DO jjj=1,M
>            X(iii,jjj)=Xfran(iii,jjj)
>          ENDDO
>          ENDDO
>        ELSE
>          DO iii=1,M
>          DO jjj=1,M
>            Xfran(iii,jjj)=X(iii,jjj)
>          ENDDO
>          ENDDO
>        ENDIF
> !
> !##########################################################!
> 
340d423
< c
431a515
> 
467c551
< !c 3) diagonalize F
---
> c 3) diagonalize F
515a600,611
> !##########################################################!
> ! FFR - PROOF IT WORKS
> !----------------------------------------------------------!
>         IF (.FALSE.) THEN
>           CALL spunpack('L',M,RMM(M1),rhoaux)
>           CALL fixrho(M,rhoaux)
>           WRITE(6,*) 'Rho sacado normal menos rho con mi codigo:'
>           WRITE(6,*) rho-rhoaux
>           WRITE(6,*) '---------------------'
>         ENDIF
> !##########################################################!
> !        fock en base OA (FFR)
517a614
> !        fock en base ON (FFR)
709a807
> 
741d838
< 
744a842
> 
746a845
> 
753a853,862
> 
> !##########################################################!
> ! FFR - NEW FORCE
> !    Copy fock matrix.
> !----------------------------------------------------------!
>        CALL spunpack('L',M,suma,fockaux)
> !       CALL MatrixTransform(M,Y,fockaux,Ytrans)
> !##########################################################!
> 
> 
759a869,870
> 
> 
935a1047,1063
> 
> !##########################################################!
> ! FFR - NEW FORCE
> !    Copy rho matrix
> !----------------------------------------------------------!
>          CALL spunpack('L',M,RMM(M1),rhoaux)
>          CALL fixrho(M,rhoaux)
>          CALL MatrixTransform(M,Ytrans,rhoaux,Y)
> 
> !         CALL MatrixTransform(M,X,rhoaux,Xtrans)
> !         rhoaux3=MATMUL(rhoaux,rhoaux2)
> !         rhoaux=3*rhoaux2-2*rhoaux3
> !         rhoaux=rhoaux*0.5
> !##########################################################!
> 
> 
> 
993a1122,1124
> 
> 
> c--------------------------------------------------------------
996c1127
<         if (npas.gt.npasw) then
---
>          if (npas.gt.npasw) then
1000a1132
> 
1005c1137,1140
<           npasw=npas+10
---
>            npasw=npas+10
>          endif
>         else
>           E=E-Ex
1008,1012c1143,1149
<       else
<         E=E-Ex
<       endif
< c calculation of energy weighted density matrix
< c
---
> 
> 
> 
> 
> !----------------------------------------------------------!
> ! Calculation of energy weighted density matrix
> !
1029a1167,1226
> 
> !
> !----------------------------------------------------------!
> !
> !
> !
> !
> !##########################################################!
> ! FFR - NEW FORCE
> !    Copy Energy Weighted Density Matrix in Q
> !----------------------------------------------------------!
>        DO jjj=1,M
>        DO iii=jjj,M
>          QM(iii,jjj)=0.0d0
>          QM(jjj,iii)=0.0d0
>          kkk=iii+(2*M-jjj)*(jjj-1)/2
>          QM(iii,jjj)=QM(iii,jjj)+RMM(M15+kkk-1)/2
>          QM(jjj,iii)=QM(jjj,iii)+RMM(M15+kkk-1)/2
>        ENDDO
>        ENDDO
> !
> !##########################################################!
> !
> !
> !
> !
> !
> !
> !##########################################################!
> ! EXTRA TEST
>        IF (.FALSE.) THEN
>          call conmut(RhoAux,FockAux,Matrix,M)
>          write(779,*) Matrix
>        ENDIF
> 
> !##########################################################!
> ! FFR - NEW FORCE
> !
> !    Codes for testing the implementation of new ways
> !    of calculating the force.
> !    Diferent ways of calculating the force.
> !
> !----------------------------------------------------------!
>        IF (.TRUE.) CALL
>      >    test_intSG(natom,M,QM)
> !
>        IF (docholesky) CALL
>      >    test_cholesky(natom,M,M15,fockaux,Xtrans,Xfran,rhoaux)
>        IF (docholesky) CALL rmm_exc_qmm(M,Xfran,rhoaux,fockaux,Xtrans)
> 
> 
>        IF (dolowdin) CALL
>      >    test_lowdin(natom,M,fockaux,Xfran,rhoaux,eigvec,eigval)
> 
> !         CALL prepQMM(M,RMM(M15),Xfran,Rhoaux,Fockaux,Xtrans)
> !##########################################################!
> 
> 
> 
> 
1109a1307,1308
> 
> 
1124a1324
> c       E=E*627.509391D0
1127,1135d1326
<       if(DIIS) then
<         deallocate (Y,Ytrans,Xtrans,fock,fockm,rho,FP_PF,FP_PFv,FP_PFm,
<      >  znano,EMAT, bcoef, suma,rho1)
<       endif
<       deallocate (xnano,rmm5,rmm13,rmm15)
< 
<       deallocate (kkind,kkinds)
<       deallocate(cool,cools)
<       if(allocated(WORK2)) deallocate (WORK2)
1137,1140c1328,1358
< c       E=E*627.509391D0
< 
<       if(timedep.eq.1) then
<         call TD()
---
> !
> !
> !
> !
> !##########################################################!
> ! EXTRA TEST
>       if (.false.) then
> !----------------------------------------------------------!
>        call conmut(RhoAux,FockAux,Matrix,M)
>        write(801,*) Matrix
> 
>        CALL spunpack('L',M,RMM,rhoaux2)
>        CALL fixrho(M,rhoaux2)
>        CALL MatrixTransform(M,Ytrans,rhoaux2,Y)
>        WRITE(802,*) rhoaux2-rhoaux
> 
> 
>        rhoaux3=rhoaux2
> !       call MatrixTransform(M,Xfran,rhoaux3,Xtrans)
> !       call messrho(M,rhoaux3)
> !       call sprepack('L',M,RMM(M1),rhoaux3)
>        call int3lu(E2)
>        call g2g_solve_groups(0,Ex,0)
>        write(807,*) (RMM(M5+iii-1),iii=1,MM)
>        CALL spunpack('L',M,RMM(M5),rhoaux3)
>        CALL MatrixTransform(M,Xtrans,rhoaux3,Xfran)
>        WRITE(803,*) rhoaux3-fockaux
> 
>        call conmut(rhoaux2,rhoaux3,Matrix,M)
>        write(804,*) Matrix
> !----------------------------------------------------------!
1142c1360,1403
< c
---
> !##########################################################!
> !
> !
> !
> ! DEALLOCATION OF VARIABLES
> !----------------------------------------------------------!
>        DEALLOCATE(Matrix)
>        DEALLOCATE(rhoaux2,rhoaux3)
>        DEALLOCATE(Xfran)
>        DEALLOCATE(eigvec,eigval)
>        DEALLOCATE(rmmaux,QM)
>        DEALLOCATE(rhoaux,fockaux,SMaux)
>        DEALLOCATE(DSX,DSY,DSZ)
>        DEALLOCATE(Lmat,Linv,Umat,Uinv)
> 
>        if(DIIS) then
>          deallocate (Y,Ytrans,Xtrans,fock,fockm,rho,FP_PF,FP_PFv,FP_PFm,
>      >   znano,EMAT, bcoef, suma,rho1)
>        endif
>        deallocate(xnano,rmm5,rmm13,rmm15)
> 
>        deallocate(kkind,kkinds)
>        deallocate(cool,cools)
>        if(allocated(WORK2)) deallocate (WORK2)
> 
> !
> !
> !
> ! TDDFT CALL
> !----------------------------------------------------------!
>        if (timedep.eq.1) then
>          call TD()
>        endif
> !
> !
> !
> !------------------------------------------------------------------------------!
>        call g2g_timer_stop('SCF')
>  766  FORMAT(I4,I4,E20.12,E20.12)
>  767  FORMAT(4(3X,E12.5))
>  520  FORMAT(4(E15.8,2x))
>  768  FORMAT(3(1X,I3),3(2X,F14.7))
>  831  FORMAT(A,3(3X,F12.5))
>  832  FORMAT(A,2(3X,F12.5),3X,A,F12.5,A)
1156c1417
<      >    '(NON OCC.)')
---
>      >       '(NON OCC.)')
1167c1428
<   45  format(E14.6E4)
---
>   45  format(E14.6E3)
1169,1173c1430,1432
< c
<       call g2g_timer_stop('SCF')
<       return
<       end
< C  -------------------------
---
> !------------------------------------------------------------------------------!
>        return;end subroutine
> !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%!
